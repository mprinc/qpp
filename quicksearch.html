<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"-_Users_sasha_Documents_data_development_nodejs_libs_qpp_index.js.html":{"id":"-_Users_sasha_Documents_data_development_nodejs_libs_qpp_index.js.html","title":"Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js /** * QPP * Copyright(c) 2015-2016 Sasha Rudan &lt;mprinc@gmail.com&gt; * MIT Licensed * Promises Augmentation &amp; Patterns library * * ```js * var QPP = require('qpp'); * ``` */ (function () { // This prevents problems when concatenating scripts that aren't strict. 'use strict'; /** * @description * ## Info * This module provides different Promise related (implemented with) patterns and sollutions * It contains semaphore implementation for syncing consumers of resources * (like simultaneous writing in files, etc), and concurrent itterators that are limited * by number of parallel execution of iterators (if we want to limit number of parallel acceses * to webservice, etc). * ## Dependencies * This module requires {@link https://www.npmjs.com/package/q | q npm module} (please check also the @see {@link https://github.com/kriskowal/q | q github}) * @module module:qpp * @requires module:q */ var Q = require('q'); // TODO: how to express that Promise is part of q module /** * @external Promise * @see {@link https://github.com/kriskowal/q/wiki/API-Reference | Q-Promise API Reference} */ var QPP = { name: 'qpp', desc: 'Promises Augmentation &amp; Patterns library', version: '1.0.0' }; /* * @exports qpp.Semaphore */ QPP.Semaphore = (function() { // TODO: what is the minimal set of tags to describe Semaphore a class that is exported as a part of QPP module /** * Constructor function. Creates a new semaphore with optional name and resources number * * @classdesc This is a class that provides promises enabled semaphores. * It is possible to create a semaphore with a name (merely fore debugging purposes) * and speciffic number of resources that we can wait for to get available, * and release them when we do not need them anymore * * @example * // Example of two consumers * var QPP = require('./..'); * var s = new QPP.Semaphore('airstrip', 1); * * // airplane (consumer) 1, waits for passangers to board * setTimeout(function(){ * s.wait() // allocating the resource (airstrip) * .then(function(){ // resource is available, consuming resource * console.log(&quot;Pilot 1: Yes! The airstrip is freee! We are the next one!&quot;); * setTimeout(function(){ * console.log(&quot;Pilot 1: Ah, view is much better here!&quot;) * s.signal(); // releasing resource (airstrip) * }, parseInt(Math.random()*1500)+1); * }); * }, parseInt(Math.random()*1500)+1); * setTimeout(function(){ // airplane (consumer) 2 * s.wait() // allocating the resource (airstrip) * .then(function(){ // resource is available, consuming resource * console.log(&quot;Pilot 2: Great we are ready to departure, no one on the airstrip!&quot;); * setTimeout(function(){ * console.log(&quot;Pilot 2: Dear passangers, enjoy our flight!&quot;) * s.signal(); // releasing resource (airstrip) * }, parseInt(Math.random()*2000)+1); * }); * }, parseInt(Math.random()*1500)+1); * * // For more examples, please check unit tests at @see qpp.Semaphore * * @memberof qpp * @alias qpp.Semaphore * @exports qpp.Semaphore * @class qpp.Semaphore * @param {string} [name=&quot;semaphore&quot;] - The name of the created semaphore * @param {number(integer)} [resourcesNo=1] - The total numer of resources available * @param {boolean} [debug=false] - Defines if debugging messages should be shown during Semaphore operations */ var Semaphore = function(name, resourcesNo, debug){ /** * @memberof! qpp.Semaphore# * @var {string} name - name of the semaphore */ this.name = name || &quot;semaphore&quot;; resourcesNo = resourcesNo || 1; /** * @memberof! qpp.Semaphore# * @private * @var {string} initialResources - initial (total) number of resources that Semaphore has */ this.initialResources = resourcesNo; /** * @memberof! qpp.Semaphore# * @var {string} resourcesNo - currently available number of resources */ this.resourcesNo = resourcesNo; /** * @memberof! qpp.Semaphore# * @private * @var {string} waitingQueue - queue holding the list of waiting consumers (functions) for available resources */ this.waitingQueue = []; /** * @memberof! qpp.Semaphore# * @var {boolean} debug - defines if debugging messages should be shown during Semaphore operations */ this.debug = typeof this.debug !== 'undefined' ? this.debug : false; }; /** * waits on semaphore * @memberof qpp.Semaphore# * @function wait * @returns {external:Promise} promise that will get resolved after the semaphore is available. * The only possibility for promise to get rejected is when semaphore gets destroyed * In that case it will get rejected with an @see {@link Error}. */ Semaphore.prototype.wait = function(){ var deferred = Q.defer(); if(this.debug) console.log(&quot;[Semaphore:%s:wait] this.resourcesNo:%d&quot;, this.name, this.resourcesNo); else{ this.resourcesNo--; // enough available resources if(this.resourcesNo&gt;=0){ if(this.debug) console.log(&quot;[Semaphore:%s:wait] available&quot;, this.name); deferred.resolve(this.resourcesNo); // no enough available resources }else{ if(this.debug) console.log(&quot;[Semaphore:%s:wait] not available&quot;, this.name); var that = this; this.waitingQueue.push(function(){ if(that.debug) console.log(&quot;[Semaphore:%s:wait:callback] became available&quot;, that.name); deferred.resolve(that.resourcesNo); }); } } return deferred.promise; }; /* Semaphore.prototype.waitWithSync = function(){ var deferred = Q.defer(); if(this.resourcesNo&gt;0){ this.resourcesNo--; deferred.resolve(this.resourcesNo); return {$available: true, $promise: deferred.promise}; }else{ var that = this; this.waitingQueue.push(function(){ deferred.resolve(that.resourcesNo); }); return {$available: false, $promise: deferred.promise}; } } */ /** * release resources in semaphore * @memberof qpp.Semaphore# * @function signal */ Semaphore.prototype.signal = function(){ if(this.debug) console.log(&quot;[Semaphore:%s:signal] this.resourcesNo:%d&quot;, this.name, this.resourcesNo); this.resourcesNo++; // someone is waiting for available resources if(this.waitingQueue.length&gt;0){ if(this.debug) console.log(&quot;[Semaphore:%s:signal] %d consumers waiting in the queue&quot;, this.name, this.waitingQueue.length); var func = this.waitingQueue.shift(); func(); }else{ if(this.debug) console.log(&quot;[Semaphore:%s:signal] no consumers waiting in the queue&quot;, this.name); } } return Semaphore; })(); /* * @exports qpp.SemaphoreMultiReservation */ QPP.SemaphoreMultiReservation = (function() { /** * Constructor function. Creates a new semaphore with optional name and resources number * * @classdesc This is a class that provides promises enabled semaphores. * It differs from the class Semaphore (@see {@link qpp.Semaphore} ) in a way * it supports allocation of more than one resource in one wait() call * * @example * // Example of 3 groups * var QPP = require('qpp'); * var s = new QPP.SemaphoreMultiReservation('Nebojsa tower', 5); * * // group 1 * setTimeout(function(){ * s.wait(3) // 3 people * .then(function(){ // resource is available, consuming resource * console.log(&quot;Group 1: Let's run to the top!&quot;); * setTimeout(function(){ * console.log(&quot;Group 1: Great experience, but they ask us to leave!&quot;) * s.signal(3); // releasing resource (toilet) * }, parseInt(Math.random()*1500)+1); * }); * }, parseInt(Math.random()*100)+1); * * // group 2 * setTimeout(function(){ * s.wait(4) // 4 people * .then(function(){ // resource is available, consuming resource * console.log(&quot;Group 2: Tower is available for us!&quot;); * setTimeout(function(){ * console.log(&quot;Group 2: Let's give the space for others!&quot;) * s.signal(4); // releasing resource (toilet) * }, parseInt(Math.random()*500)+1); * }); * }, parseInt(Math.random()*100)+1); * * // group 3 * setTimeout(function(){ * s.wait(2) // 2 people * .then(function(){ // resource is available, consuming resource * console.log(&quot;Group 3: Hey, i have to show you the view!&quot;); * setTimeout(function(){ * console.log(&quot;Group 3: Ah, we could stay here forever!&quot;) * s.signal(2); // releasing resource (toilet) * }, parseInt(Math.random()*100)+1); * }); * }, parseInt(Math.random()*100)+1); * * // This is the most interesting scenario: * // Group 2: Tower is available for us * // Group 2: Let's give the space for others * // Group 3: Hey, i have to show you the view * // Group 1: Let's run to the top * // Group 3: Ah, we could stay here forever * // Group 1: Great experience, but they ask us to leave! * // Because both group 1 and 3 ended up at the top of the towe simultaneously * // (there were enough of resources to allocate for both (2+3&lt;=5)) * // * // For more examples, please check unit tests at @see qpp.mapBandwidth * * @memberof qpp * @exports qpp.Semaphore * @class qpp.SemaphoreMultiReservation * @param {string} [name=&quot;semaphore&quot;] - The name of the created semaphore * @param {number(integer)} [resourcesNo=1] - The total numer of resources available * @param {boolean} [debug=false] - Defines if debugging messages should be shown during Semaphore operations * @param {boolean} [waitForMoreDemandingConsumers=true] - Defines if consumer can allocate resources even if other consumer waits for available resources (but needs more resources than currently available) */ var SemaphoreMultiReservation = function(name, resourcesNo, waitForMoreDemandingConsumers){ /** * @memberof! qpp.SemaphoreMultiReservation# * @var {string} name - name of the semaphore */ this.name = name || &quot;semaphore&quot;; /** * @memberof! qpp.SemaphoreMultiReservation# * @private * @var {string} initialResources - initial (total) number of resources that semaphore has */ this.initialResources = resourcesNo; /** * @memberof! qpp.SemaphoreMultiReservation# * @var {string} resourcesNo - currently available number of resources */ this.resourcesNo = resourcesNo; /** * @memberof! qpp.SemaphoreMultiReservation# * @private * @var {string} waitingQueue - queue holding the list of waiting consumers (functions) for available resources */ this.waitingQueue = []; /** * @memberof! qpp.SemaphoreMultiReservation# * @var {boolean} waitForMoreDemandingConsumers=true - defines if consumer can allocate resources even if other consumer waits for available resources (but needs more resources than currently available) * @example * var s = new Semaphore('s', 3); * var wP1 = s.wait(1); // fine, 2 resources left available * var wP2 = s.wait(3); // not fine (consumer 1 has to release) * // wP3 will be fine and resolved if {@link this.waitForMoreDemandingConsumers} === false * // or not fine and not resolved until consumer 1's resources are released (signaled) * // if {@link this.waitForMoreDemandingConsumers} === true (default) * var wP3 = s.wait(2); */ this.waitForMoreDemandingConsumers = typeof waitForMoreDemandingConsumers !== 'undefined' ? waitForMoreDemandingConsumers : true; /** * @memberof! qpp.SemaphoreMultiReservation# * @var {boolean} debug - defines if debugging messages should be shown during Semaphore operations */ this.debug = typeof this.debug !== 'undefined' ? this.debug : false; }; /** * waits on semaphore * @memberof qpp.SemaphoreMultiReservation# * @function wait * @param {number} [resourcesNoNeeded=&quot;1&quot;] - The numer of resources needed * @returns {external:Promise} promise that will get resolved after the semaphore is available/ * The only possibility for promise to get rejected is when semaphore gets destroyed * In that case it will get rejected with an @see {@link Error}. */ SemaphoreMultiReservation.prototype.wait = function(resourcesNoNeeded){ var deferred = Q.defer(); resourcesNoNeeded = resourcesNoNeeded || 1; if(resourcesNoNeeded &gt; this.initialResources) deferred.reject(new Error(&quot;Not possible to allocate more resources than were initially available&quot;)); else{ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:wait] this.resourcesNo:%d, resourcesNoNeeded:%d&quot;, this.name, this.resourcesNo, resourcesNoNeeded); // enough available resources and (no one is waiting on semaphore or it is allowed to get resources before) if((this.resourcesNo &gt;= resourcesNoNeeded) &amp;&amp; (this.waitingQueue.length &lt;= 0 || !this.waitForMoreDemandingConsumers)){ this.resourcesNo -= resourcesNoNeeded; // allocation if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:wait] available&quot;, this.name); deferred.resolve(this.resourcesNo); // no enough available resources }else{ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:wait] not available&quot;, this.name); var that = this; this.waitingQueue.push({ func: function(){ if(that.debug) console.log(&quot;[Semaphore:%s:wait:callback] became available&quot;, that.name); deferred.resolve(that.resourcesNo); }, rNo: resourcesNoNeeded }); } } return deferred.promise; }; /* SemaphoreMultiReservation.prototype.waitWithSync = function(){ var deferred = Q.defer(); if(this.resourcesNo&gt;0){ this.resourcesNo--; deferred.resolve(this.resourcesNo); return {$available: true, $promise: deferred.promise}; }else{ var that = this; this.waitingQueue.push(function(){ deferred.resolve(that.resourcesNo); }); return {$available: false, $promise: deferred.promise}; } } */ /** * release resources in semaphore * @memberof qpp.SemaphoreMultiReservation# * @function signal * @param {number} [resourcesReleased=&quot;1&quot;] - The numer of resources released */ SemaphoreMultiReservation.prototype.signal = function(resourcesReleased){ resourcesReleased = resourcesReleased || 1; if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:signal] this.resourcesNo:%d, resourcesReleased:%d&quot;, this.name, this.resourcesNo, resourcesReleased); this.resourcesNo += resourcesReleased; // someone is waiting for available resources if(this.waitingQueue.length&gt;0){ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:signal] %d consumers waiting in the queue&quot;, this.name, this.waitingQueue.length); do{ var qEl = this.waitingQueue[0]; if(this.resourcesNo &gt;= qEl.rNo){ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:signal] releasing a consumer&quot;); this.waitingQueue.shift(); this.resourcesNo -= qEl.rNo; // allocating qEl.func(); }else{ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:signal] consumer needs too much resources (needed %d out of %s available)&quot;, this.name, qEl.rNo, this.resourcesNo); break; } }while(this.waitingQueue.length&gt;0); }else{ if(this.debug) console.log(&quot;[SemaphoreMultiReservation:%s:signal] no consumers waiting in the queue&quot;, this.name); } } return SemaphoreMultiReservation; })(); /* * @exports qpp.SemaphoresHash */ QPP.SemaphoresHash = (function() { /** * Constructor function. Creates a new SemaphoresHash with optional and resources number * * @classdesc This is a class that provides promises enabled SemaphoresHashes. * It is possible to create a SemaphoresHash with a name and speciffic number of resources that we can wait for to get available, * and release them when we do not need them anymore * * @example * // Example of two consumers * var QPP = require('./..'); * var s = new QPP.SemaphoresHash(1); * * // airplane (consumer) 1, waits for passangers to board * setTimeout(function(){ * s.wait() // allocating the resource (airstrip) * .then(function(){ // resource is available, consuming resource * console.log(&quot;Pilot 1: Yes! The airstrip is freee! We are the next one!&quot;); * setTimeout(function(){ * console.log(&quot;Pilot 1: Ah, view is much better here!&quot;) * s.signal(); // releasing resource (airstrip) * }, parseInt(Math.random()*1500)+1); * }); * }, parseInt(Math.random()*1500)+1); * setTimeout(function(){ // airplane (consumer) 2 * s.wait() // allocating the resource (airstrip) * .then(function(){ // resource is available, consuming resource * console.log(&quot;Pilot 2: Great we are ready to departure, no one on the airstrip!&quot;); * setTimeout(function(){ * console.log(&quot;Pilot 2: Dear passangers, enjoy our flight!&quot;) * s.signal(); // releasing resource (airstrip) * }, parseInt(Math.random()*2000)+1); * }); * }, parseInt(Math.random()*1500)+1); * * // For more examples, please check unit tests at @see qpp.SemaphoresHash * * @memberof qpp * @alias qpp.SemaphoresHash * @exports qpp.SemaphoresHash * @class qpp.SemaphoresHash * @param {string} [name=&quot;SemaphoresHash&quot;] - The name of the created SemaphoresHash * @param {number(integer)} [resourcesNo=1] - The total numer of resources available * @param {boolean} [debug=false] - Defines if debugging messages should be shown during SemaphoresHash operations */ var SemaphoresHash = function(resourcesNo, debug){ resourcesNo = resourcesNo || 1; /** * @memberof! qpp.SemaphoresHash# * @var {Array.&lt;string,QPP.Semaphore&gt;} semaphores - array hash of semaphores */ this.semaphores = {}; /** * @memberof! qpp.SemaphoresHash# * @private * @var {string} initialResources - initial (total) number of resources that SemaphoresHash has */ this.initialResources = resourcesNo; /** * @memberof! qpp.SemaphoresHash# * @var {boolean} debug - defines if debugging messages should be shown during SemaphoresHash operations */ this.debug = typeof this.debug !== 'undefined' ? this.debug : false; }; /** * create named semaphore in SemaphoresHash * @memberof qpp.SemaphoresHash# * @function create * @returns {QPP.Semaphore} returns newly created semaphore */ SemaphoresHash.prototype.create = function(name){ if(!(name in this.semaphores)){ var semaphore = this.semaphores[name] = new QPP.Semaphore(name, this.initialResources); }else{ var semaphore = this.semaphores[name]; } return semaphore; }; /** * waits on SemaphoresHash * @memberof qpp.SemaphoresHash# * @function wait * @returns {external:Promise} promise that will get resolved after the named semaphore in the SemaphoresHash is available. * The only possibility for promise to get rejected is when SemaphoresHash gets destroyed * In that case it will get rejected with an @see {@link Error}. */ SemaphoresHash.prototype.wait = function(name){ if(!(name in this.semaphores)){ var semaphore = this.semaphores[name] = new QPP.Semaphore(name, this.initialResources); }else{ var semaphore = this.semaphores[name]; } return semaphore.wait(); }; /** * release resources in the named of the SemaphoresHash * @memberof qpp.SemaphoresHash# * @function signal */ SemaphoresHash.prototype.signal = function(name){ if(!(name in this.semaphores)){ var semaphore = this.semaphores[name] = new QPP.Semaphore(name, this.initialResources); }else{ var semaphore = this.semaphores[name]; } return semaphore.signal(); } return SemaphoresHash; })(); /** * This is a type (a signature) of a processing function (callback) that is called for every element to be processed in the case of itterators (mapBandwidth, etc) * @callback processingFunctionCallback * @param {*} dataElement - data element to be processed * @param {number(index)} index - index of the processing element in the array * @param {...*} [processingArgs] - additional arguments passed with options.processingArguments * @param {processingFunctionFinishedCallback} callback - callback from the processing function back, when the processing is finished * @returns {Promise} promise that will get realized after function is available */ /** * This is a type (a signature) of a processing function callback, called back from the processing function {@link processingFunctionCallback}. Processing function calls the iterator (mapBandwidth etc) when it finishes processing the processing element. * Note: the more preferred way is that function returns a promise and communicate with iterator through the promise instead through callback * @callback processingFunctionFinishedCallback @see {@link processingFunctionCallback} * @param {number(index)} index - index of the processing element in the array that has been processed @see {@link processingFunctionCallback} */ /** * @example * var Q = require('q'); * var QPP = require('./..'); * * var iterator = {}; * var sum = 0; * var processingFunction = function(data, index){ * console.log(&quot;[processingFunction:starting] data: %s, iterator.processingCurrentNo: %d&quot;, data, iterator.processingCurrentNo); * // test for the limit of concurrently running functions * var defered = Q.defer(); * setTimeout(function(){ * sum += data; * console.log(&quot;[processingFunction:finishing] data: %s, iterator.processingCurrentNo: %d&quot;, data, iterator.processingCurrentNo); * defered.resolve(); * }, parseInt(Math.random()*100)+1); * * return defered.promise; * }; * * var options = {}; * options.processingData = [0, 1, 2, 3, 4, 5]; * options.limitConcurrentlyNum = 3; * options.processingFunction = processingFunction; * iterator = QPP.mapBandwidth(options, iterator); * * var promise = iterator.$promise; * * promise.then(function(processedNo){ * console.log(&quot;Done: processed: %d, sum: %d&quot;, processedNo, sum); * }); * * @exports qpp.mapBandwidth * @function mapBandwidth - Bandwidth limited iteration * @param {Object} options - Parameters * @param {string} options.name - the name of the iterator * @param {Array.&lt;*&gt;} options.processingData - an array that has to be processed. For each element of array the options.processingFunction will be invited to process it * @param {processingFunctionCallback} options.processingFunction - function that is called for processing data * @param {Object} [options.thisObj] - the object/context in which processing function will be called * @param {Array.&lt;*&gt;} [options.processingArguments] - arguments that will be passed to the options.processingFunction in addition to element to process and few other maintance parameters * @param {number(integer)} options.limitConcurrentlyNum - the number of concurrently processing array elements (calls to the options.processingFunction) * @param {number(integer)} options.limitPerSecond - the maximum number array elements to process per second * @param {boolean} options.debug - defines if debugging messages should be shown during mapBandwidth processing * @param {Object} [iterator={}] iterator that keeps information of the iteration status and options * @return {Object} iterator that keeps information of the iteration status and options */ QPP.mapBandwidth = function(options, iterator){ iterator = iterator || {}; var deferred = Q.defer(); iterator.$promise = deferred.promise; if(typeof options == 'undefined'){ deferred.reject(new Error(&quot;[MapBandwidth] Missing options&quot;)); return iterator; } iterator.name = options.name || &quot;no-name&quot;; iterator.thisObj = options.thisObj, iterator.processingFunction = options.processingFunction; iterator.processingData = options.processingData; iterator.processingArguments = options.processingArguments; iterator.limitConcurrentlyNum = options.limitConcurrentlyNum || 1; iterator.limitPerSecond = options.limitPerSecond; iterator.debug = typeof options.debug !== 'undefined' ? options.debug : false; if(typeof options.processingFunction === 'undefined'){ deferred.reject(new Error(&quot;[MapBandwidth:&quot;+iterator.name+&quot;] Missing processingFunction&quot;)); return iterator; } if(typeof options.processingData === 'undefined'){ deferred.reject(new Error(&quot;[MapBandwidth:&quot;+iterator.name+&quot;] Missing processingData&quot;)); return iterator; } iterator.promises = []; iterator.processingIterator = 0; iterator.processingCurrentNo = 0; var processingFunctionFinished = function(){ iterator.processingCurrentNo--; addProcessingFunctions(); }; var addProcessingFunctions = function(){ while(iterator.processingIterator &lt; iterator.processingData.length &amp;&amp; iterator.processingCurrentNo &lt; iterator.limitConcurrentlyNum){ iterator.processingCurrentNo++; if(options.processingArguments) { var procArguments = [iterator.processingData[iterator.processingIterator], iterator.processingIterator]; // http://stackoverflow.com/questions/1374126/how-to-extend-an-existing-javascript-array-with-another-array procArguments.push.apply(procArguments, options.processingArguments); procArguments.push(processingFunctionFinished); if(iterator.debug) console.log(&quot;[MapBandwidth:&quot;+iterator.name+&quot;] iterator.processingIterator: %d, procArguments:%s&quot;, iterator.processingIterator, JSON.stringify(procArguments)); var promise = iterator.processingFunction.apply(iterator.thisObj || this, procArguments); }else{ if(iterator.thisObj){ var promise = iterator.processingFunction.call(iterator.thisObj, iterator.processingData[iterator.processingIterator], iterator.processingIterator, processingFunctionFinished); }else{ var promise = iterator.processingFunction(iterator.processingData[iterator.processingIterator], iterator.processingIterator, processingFunctionFinished); } } iterator.processingIterator++; if(typeof promise !== 'undefined' &amp;&amp; ('then' in promise)) promise.then(function(){ processingFunctionFinished(); }).done(); } if(iterator.processingCurrentNo == 0) deferred.resolve(iterator.processingData.length); } addProcessingFunctions(); return iterator; }; QPP.mapBandwidthDataList = function(processingFunction, processingData){ }; QPP.mapBandwidthArgumentsList = function(processingFunction, processingData){ }; // node.js world module.exports = (function() { return QPP; })(); }()); // end of 'use strict'; × Search results Close This work is contribution to nodejs open source community "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Modules Classes Semaphore SemaphoreMultiReservation SemaphoresHash × Search results Close This work is contribution to nodejs open source community "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Classes Classes Semaphore SemaphoreMultiReservation SemaphoresHash × Search results Close This work is contribution to nodejs open source community "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Externals Classes Semaphore SemaphoreMultiReservation SemaphoresHash × Search results Close This work is contribution to nodejs open source community "},"index.html":{"id":"index.html","title":"Index","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise qpp========= Promises Augmentation &amp; Patterns Installationnpm install qpp --saveFeatures Support for limiting a bandwidth of executing a set of function by the number of concurrent running functions (TODO) by the number of functions running at particular time period Support for parallelism Semaphores single resource allocation multiple resources allocation Semaphores hash collection of semaphores, each addressed by unique name Plans to add (please create new issue to ask for it) Time bandwidth Usage// Example of two consumers var QPP = require('./..'); var s = new QPP.Semaphore('airstrip', 1); // airplane (consumer) 1, waits for passengers to board setTimeout(function(){ s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 1: Yes! The airstrip is freee! We are the next one!&quot;); setTimeout(function(){ console.log(&quot;Pilot 1: Ah, view is much better here!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*1500)+1); }); }, parseInt(Math.random()*1500)+1); setTimeout(function(){ // airplane (consumer) 2 s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 2: Great we are ready to departure, no one on the airstrip!&quot;); setTimeout(function(){ console.log(&quot;Pilot 2: Dear passangers, enjoy our flight!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*2000)+1); }); }, parseInt(Math.random()*1500)+1); // For more examples, please check unit tests at @see qpp.SemaphorePlease check documentation for detailed documentation and basic examples. For more detailed and complex examples, please check the test folder in the repository Testnpm testRelease History 1.0.0 Initial release × Search results Close This work is contribution to nodejs open source community "},"external-Promise.html":{"id":"external-Promise.html","title":"External: Promise","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise External: Promise qpp~ Promise Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 32 See: Q-Promise API Reference × Search results Close This work is contribution to nodejs open source community "},"module-qpp.html":{"id":"module-qpp.html","title":"Module: qpp","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Module: qpp InfoThis module provides different Promise related (implemented with) patterns and sollutions It contains semaphore implementation for syncing consumers of resources (like simultaneous writing in files, etc), and concurrent itterators that are limited by number of parallel execution of iterators (if we want to limit number of parallel acceses to webservice, etc). DependenciesThis module requires q npm module (please check also the @see q github) Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 15 Requires module:q Methods &lt;inner&gt; mapBandwidth - Bandwidth limited iteration(options, iterator) Parameters: Name Type Argument Default Description options Object Parameters Properties Name Type Argument Description name string the name of the iterator processingData Array.&lt;*&gt; an array that has to be processed. For each element of array the options.processingFunction will be invited to process it processingFunction processingFunctionCallback function that is called for processing data thisObj Object &lt;optional&gt; the object/context in which processing function will be called processingArguments Array.&lt;*&gt; &lt;optional&gt; arguments that will be passed to the options.processingFunction in addition to element to process and few other maintance parameters limitConcurrentlyNum number(integer) the number of concurrently processing array elements (calls to the options.processingFunction) limitPerSecond number(integer) the maximum number array elements to process per second debug boolean defines if debugging messages should be shown during mapBandwidth processing iterator Object &lt;optional&gt; {} iterator that keeps information of the iteration status and options Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 533 Returns: iterator that keeps information of the iteration status and options Type Object Example var Q = require('q'); var QPP = require('./..'); var iterator = {}; var sum = 0; var processingFunction = function(data, index){ console.log(&quot;[processingFunction:starting] data: %s, iterator.processingCurrentNo: %d&quot;, data, iterator.processingCurrentNo); // test for the limit of concurrently running functions var defered = Q.defer(); setTimeout(function(){ sum += data; console.log(&quot;[processingFunction:finishing] data: %s, iterator.processingCurrentNo: %d&quot;, data, iterator.processingCurrentNo); defered.resolve(); }, parseInt(Math.random()*100)+1); return defered.promise; }; var options = {}; options.processingData = [0, 1, 2, 3, 4, 5]; options.limitConcurrentlyNum = 3; options.processingFunction = processingFunction; iterator = QPP.mapBandwidth(options, iterator); var promise = iterator.$promise; promise.then(function(processedNo){ console.log(&quot;Done: processed: %d, sum: %d&quot;, processedNo, sum); }); Type Definitions processingFunctionCallback(dataElement, index, processingArgs, callback) This is a type (a signature) of a processing function (callback) that is called for every element to be processed in the case of itterators (mapBandwidth, etc) Parameters: Name Type Argument Description dataElement * data element to be processed index number(index) index of the processing element in the array processingArgs * &lt;optional&gt; &lt;repeatable&gt; additional arguments passed with options.processingArguments callback processingFunctionFinishedCallback callback from the processing function back, when the processing is finished Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 516 Returns: promise that will get realized after function is available Type Promise processingFunctionFinishedCallback(index) This is a type (a signature) of a processing function callback, called back from the processing function processingFunctionCallback. Processing function calls the iterator (mapBandwidth etc) when it finishes processing the processing element. Note: the more preferred way is that function returns a promise and communicate with iterator through the promise instead through callback Parameters: Name Type Description index number(index) index of the processing element in the array that has been processed @see processingFunctionCallback Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 526 × Search results Close This work is contribution to nodejs open source community "},"qpp.Semaphore.html":{"id":"qpp.Semaphore.html","title":"Class: Semaphore","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Class: Semaphore Semaphore This is a class that provides promises enabled semaphores. It is possible to create a semaphore with a name (merely fore debugging purposes) and speciffic number of resources that we can wait for to get available, and release them when we do not need them anymore new Semaphore(name, resourcesNo, debug) Constructor function. Creates a new semaphore with optional name and resources number Parameters: Name Type Argument Default Description name string &lt;optional&gt; &quot;semaphore&quot; The name of the created semaphore resourcesNo number(integer) &lt;optional&gt; 1 The total numer of resources available debug boolean &lt;optional&gt; false Defines if debugging messages should be shown during Semaphore operations Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 50 Example // Example of two consumers var QPP = require('./..'); var s = new QPP.Semaphore('airstrip', 1); // airplane (consumer) 1, waits for passangers to board setTimeout(function(){ s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 1: Yes! The airstrip is freee! We are the next one!&quot;); setTimeout(function(){ console.log(&quot;Pilot 1: Ah, view is much better here!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*1500)+1); }); }, parseInt(Math.random()*1500)+1); setTimeout(function(){ // airplane (consumer) 2 s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 2: Great we are ready to departure, no one on the airstrip!&quot;); setTimeout(function(){ console.log(&quot;Pilot 2: Dear passangers, enjoy our flight!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*2000)+1); }); }, parseInt(Math.random()*1500)+1); // For more examples, please check unit tests at @see qpp.Semaphore Members #debug :boolean defines if debugging messages should be shown during Semaphore operations Type: boolean Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 121 #name :string name of the semaphore Type: string Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 97 #resourcesNo :string currently available number of resources Type: string Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 109 Methods signal() release resources in semaphore Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 173 wait() waits on semaphore Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 128 Returns: promise that will get resolved after the semaphore is available. The only possibility for promise to get rejected is when semaphore gets destroyed In that case it will get rejected with an @see Error. Type external:Promise × Search results Close This work is contribution to nodejs open source community "},"qpp.SemaphoreMultiReservation.html":{"id":"qpp.SemaphoreMultiReservation.html","title":"Class: SemaphoreMultiReservation","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Class: SemaphoreMultiReservation SemaphoreMultiReservation This is a class that provides promises enabled semaphores. It differs from the class Semaphore (@see qpp.Semaphore ) in a way it supports allocation of more than one resource in one wait() call new SemaphoreMultiReservation(name, resourcesNo, debug, waitForMoreDemandingConsumers) Constructor function. Creates a new semaphore with optional name and resources number Parameters: Name Type Argument Default Description name string &lt;optional&gt; &quot;semaphore&quot; The name of the created semaphore resourcesNo number(integer) &lt;optional&gt; 1 The total numer of resources available debug boolean &lt;optional&gt; false Defines if debugging messages should be shown during Semaphore operations waitForMoreDemandingConsumers boolean &lt;optional&gt; true Defines if consumer can allocate resources even if other consumer waits for available resources (but needs more resources than currently available) Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 198 Example // Example of 3 groups var QPP = require('qpp'); var s = new QPP.SemaphoreMultiReservation('Nebojsa tower', 5); // group 1 setTimeout(function(){ s.wait(3) // 3 people .then(function(){ // resource is available, consuming resource console.log(&quot;Group 1: Let's run to the top!&quot;); setTimeout(function(){ console.log(&quot;Group 1: Great experience, but they ask us to leave!&quot;) s.signal(3); // releasing resource (toilet) }, parseInt(Math.random()*1500)+1); }); }, parseInt(Math.random()*100)+1); // group 2 setTimeout(function(){ s.wait(4) // 4 people .then(function(){ // resource is available, consuming resource console.log(&quot;Group 2: Tower is available for us!&quot;); setTimeout(function(){ console.log(&quot;Group 2: Let's give the space for others!&quot;) s.signal(4); // releasing resource (toilet) }, parseInt(Math.random()*500)+1); }); }, parseInt(Math.random()*100)+1); // group 3 setTimeout(function(){ s.wait(2) // 2 people .then(function(){ // resource is available, consuming resource console.log(&quot;Group 3: Hey, i have to show you the view!&quot;); setTimeout(function(){ console.log(&quot;Group 3: Ah, we could stay here forever!&quot;) s.signal(2); // releasing resource (toilet) }, parseInt(Math.random()*100)+1); }); }, parseInt(Math.random()*100)+1); // This is the most interesting scenario: // Group 2: Tower is available for us // Group 2: Let's give the space for others // Group 3: Hey, i have to show you the view // Group 1: Let's run to the top // Group 3: Ah, we could stay here forever // Group 1: Great experience, but they ask us to leave! // Because both group 1 and 3 ended up at the top of the towe simultaneously // (there were enough of resources to allocate for both (2+3&lt;=5)) // // For more examples, please check unit tests at @see qpp.mapBandwidth Members #debug :boolean defines if debugging messages should be shown during Semaphore operations Type: boolean Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 305 #name :string name of the semaphore Type: string Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 267 #resourcesNo :string currently available number of resources Type: string Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 280 #waitForMoreDemandingConsumers :boolean defines if consumer can allocate resources even if other consumer waits for available resources (but needs more resources than currently available) Type: boolean Default Value: true Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 291 Example var s = new Semaphore('s', 3); var wP1 = s.wait(1); // fine, 2 resources left available var wP2 = s.wait(3); // not fine (consumer 1 has to release) // wP3 will be fine and resolved if this.waitForMoreDemandingConsumers === false // or not fine and not resolved until consumer 1's resources are released (signaled) // if this.waitForMoreDemandingConsumers === true (default) var wP3 = s.wait(2); Methods signal(resourcesReleased) release resources in semaphore Parameters: Name Type Argument Default Description resourcesReleased number &lt;optional&gt; &quot;1&quot; The numer of resources released Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 363 wait(resourcesNoNeeded) waits on semaphore Parameters: Name Type Argument Default Description resourcesNoNeeded number &lt;optional&gt; &quot;1&quot; The numer of resources needed Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 312 Returns: promise that will get resolved after the semaphore is available/ The only possibility for promise to get rejected is when semaphore gets destroyed In that case it will get rejected with an @see Error. Type external:Promise × Search results Close This work is contribution to nodejs open source community "},"qpp.SemaphoresHash.html":{"id":"qpp.SemaphoresHash.html","title":"Class: SemaphoresHash","body":" QPP (Promises Augmentation &amp; Patterns) Modules qpp Classes qpp.Semaphoreqpp.SemaphoreMultiReservationqpp.SemaphoresHash Externals Promise Class: SemaphoresHash SemaphoresHash This is a class that provides promises enabled SemaphoresHashes. It is possible to create a SemaphoresHash with a name and speciffic number of resources that we can wait for to get available, and release them when we do not need them anymore new SemaphoresHash(name, resourcesNo, debug) Constructor function. Creates a new SemaphoresHash with optional and resources number Parameters: Name Type Argument Default Description name string &lt;optional&gt; &quot;SemaphoresHash&quot; The name of the created SemaphoresHash resourcesNo number(integer) &lt;optional&gt; 1 The total numer of resources available debug boolean &lt;optional&gt; false Defines if debugging messages should be shown during SemaphoresHash operations Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 401 Example // Example of two consumers var QPP = require('./..'); var s = new QPP.SemaphoresHash(1); // airplane (consumer) 1, waits for passangers to board setTimeout(function(){ s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 1: Yes! The airstrip is freee! We are the next one!&quot;); setTimeout(function(){ console.log(&quot;Pilot 1: Ah, view is much better here!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*1500)+1); }); }, parseInt(Math.random()*1500)+1); setTimeout(function(){ // airplane (consumer) 2 s.wait() // allocating the resource (airstrip) .then(function(){ // resource is available, consuming resource console.log(&quot;Pilot 2: Great we are ready to departure, no one on the airstrip!&quot;); setTimeout(function(){ console.log(&quot;Pilot 2: Dear passangers, enjoy our flight!&quot;) s.signal(); // releasing resource (airstrip) }, parseInt(Math.random()*2000)+1); }); }, parseInt(Math.random()*1500)+1); // For more examples, please check unit tests at @see qpp.SemaphoresHash Members #debug :boolean defines if debugging messages should be shown during SemaphoresHash operations Type: boolean Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 460 #semaphores :Array.&lt;string, QPP.Semaphore&gt; array hash of semaphores Type: Array.&lt;string, QPP.Semaphore&gt; Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 448 Methods create() create named semaphore in SemaphoresHash Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 467 Returns: returns newly created semaphore Type QPP.Semaphore signal() release resources in the named of the SemaphoresHash Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 499 wait() waits on SemaphoresHash Source: /Users/sasha/Documents/data/development/nodejs/libs/qpp/index.js, line 482 Returns: promise that will get resolved after the named semaphore in the SemaphoresHash is available. The only possibility for promise to get rejected is when SemaphoresHash gets destroyed In that case it will get rejected with an @see Error. Type external:Promise × Search results Close This work is contribution to nodejs open source community "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
